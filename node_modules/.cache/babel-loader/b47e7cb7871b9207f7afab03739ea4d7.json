{"ast":null,"code":"var _jsxFileName = \"/Users/juvenal/Desktop/projects/StructureVisualizer/structure-vis/src/DataStructureVisualizer/Tile.js\";\nimport React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Tile(props) {\n  const {\n    col,\n    row,\n    sType,\n    sId,\n    st,\n    setSt,\n    ch,\n    setCh,\n    gr,\n    setGr,\n    isP,\n    op,\n    setOp,\n    type,\n    count,\n    setCount,\n    txt\n  } = props;\n\n  const stackGrid = size => {\n    if (row - size >= -1) {\n      const newGrid = gr.slice();\n      let tile,\n          newTile,\n          arow,\n          coor = [];\n\n      for (let i = 0; i < size; i++) {\n        arow = row - i;\n        tile = newGrid[arow][col];\n        newTile = { ...tile,\n          isPicked: !isP,\n          strType: type.STACK,\n          strId: count\n        };\n        newGrid[arow][col] = newTile;\n        coor.push([arow, col]);\n      }\n\n      setGr(newGrid);\n      let newCount = count + 1;\n      setCount(newCount);\n      const newSt = st.slice(); //copy list of data structues\n\n      newSt.push({\n        id: count,\n        tile: coor\n      });\n      setSt(newSt);\n    }\n  };\n\n  const arrayGrid = size => {\n    //setOp(\"\")\n    if (col + size <= 45) {\n      const newGrid = gr.slice();\n      let tile,\n          newTile,\n          acol,\n          coor = [];\n\n      for (let i = 0; i < size; i++) {\n        tile = newGrid[row][col + i];\n        newTile = { ...tile,\n          isPicked: !isP,\n          strType: type.ARRAY,\n          strId: count\n        };\n        newGrid[row][col + i] = newTile;\n        acol = col + i;\n        coor.push([row, acol]);\n      }\n\n      setGr(newGrid);\n      let newCount = count + 1;\n      setCount(newCount);\n      const newSt = st.slice(); //copy list of data structues\n\n      newSt.push({\n        id: count,\n        tile: coor\n      });\n      setSt(newSt);\n      console.log(st);\n    }\n  };\n\n  const queueGrid = size => {\n    if (col - size >= -1) {\n      const newGrid = gr.slice();\n      let tile,\n          newTile,\n          acol,\n          coor = [];\n\n      for (let i = 0; i < size; i++) {\n        acol = col - i;\n        tile = newGrid[row][acol];\n        newTile = { ...tile,\n          isPicked: !isP,\n          strType: type.QUEUE,\n          strId: count\n        };\n        newGrid[row][acol] = newTile;\n        coor.push([row, acol]);\n      }\n\n      setGr(newGrid);\n      let newCount = count + 1;\n      setCount(newCount);\n      const newSt = st.slice(); //copy list of data structues\n\n      newSt.push({\n        id: count,\n        tile: coor\n      });\n      setSt(newSt);\n    }\n  };\n\n  const mapGrid = size => {\n    if (col + 2 <= 44 && row + size <= 20) {\n      const newGrid = gr.slice();\n      let tile,\n          newTile,\n          coor = [],\n          arr,\n          r,\n          c;\n\n      for (let i = 0; i < size; i++) {\n        arr = [];\n\n        for (let j = 0; j < 3; j++) {\n          r = row + i;\n          c = col + j;\n          tile = newGrid[r][c];\n          newTile = { ...tile,\n            isPicked: !isP,\n            strType: type.MAP,\n            strId: count\n          };\n          newGrid[r][c] = newTile; //update tile in copy grid\n\n          arr.push([r, c]); //pushes for single key/value\n        }\n\n        coor.push(arr);\n      }\n\n      setGr(newGrid);\n      let newCount = count + 1;\n      setCount(newCount);\n      const newSt = st.slice(); //copy list of data structues\n\n      newSt.push({\n        id: count,\n        tile: coor\n      });\n      setSt(newSt);\n    }\n  };\n\n  const treeGrid = () => {\n    //setOp(\"\")\n    const newGrid = gr.slice();\n    let tile,\n        newTile,\n        pRow,\n        pCol,\n        coor = [[row, col]]; // create  root tile\n\n    tile = newGrid[row][col];\n    newTile = { ...tile,\n      isPicked: !isP,\n      strType: type.TREE,\n      strId: count\n    };\n    newGrid[row][col] = newTile;\n    coor.push([row, col]); //create children tiles\n\n    let offset = [4, 4, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1],\n        neg = -1;\n\n    for (let i = 0; i < 7; i++) {\n      console.log(coor);\n      [pRow, pCol] = coor[i];\n\n      for (let j = 1; j < 3; j++) {\n        pRow += 1;\n        pCol = pCol + offset[i] * neg;\n        tile = newGrid[pRow][pCol];\n        newTile = { ...tile,\n          isPicked: !isP,\n          strType: type.TREE,\n          strId: count\n        };\n        neg *= -1;\n        newGrid[pRow + 1][pCol + offset[i] * neg] = newTile;\n        coor.push([pRow + 1, pCol + offset[i] * neg]);\n      }\n    }\n\n    setGr(newGrid);\n    let newCount = count + 1;\n    setCount(newCount);\n    const newSt = st.slice(); //copy list of data structues\n\n    newSt.push({\n      id: count,\n      tile: coor\n    });\n    setSt(newSt);\n    console.log(st);\n  };\n\n  const click = () => {\n    if (sId === 0) {\n      if (op !== \"\") {\n        /*let size= parseInt(prompt(\"Size:\"),10)\n        if(op === \"Array\")\n            arrayGrid(size)\n        else if(op === \"Stack\")\n            stackGrid(size)\n        else if(op === \"Queue\")\n            queueGrid(size)\n        else if(op === \"HashMap\")\n            mapGrid(size)\n        else */\n        if (op === \"Tree\") treeGrid();else if (op === \"Graph\") console.log(\"nothing yet\");\n      }\n    } else {\n      setCh({\n        id: sId,\n        type: sType\n      });\n    }\n  };\n\n  const extra = sId === ch.id ? 'highlight' : '';\n  const main = sType === `` ? `` : sType === type.ARRAY ? `array` : sType === type.STACK ? `stack` : sType === type.QUEUE ? `queue` : sType === type.MAP ? `map` : sType === type.TREE ? `tree` : `graph`;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: ` myTile ${main} ${extra}`,\n    onClick: () => click(),\n    children: txt\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 222,\n    columnNumber: 9\n  }, this);\n}\n\n_c = Tile;\nexport default Tile;\n\nvar _c;\n\n$RefreshReg$(_c, \"Tile\");","map":{"version":3,"sources":["/Users/juvenal/Desktop/projects/StructureVisualizer/structure-vis/src/DataStructureVisualizer/Tile.js"],"names":["React","Tile","props","col","row","sType","sId","st","setSt","ch","setCh","gr","setGr","isP","op","setOp","type","count","setCount","txt","stackGrid","size","newGrid","slice","tile","newTile","arow","coor","i","isPicked","strType","STACK","strId","push","newCount","newSt","id","arrayGrid","acol","ARRAY","console","log","queueGrid","QUEUE","mapGrid","arr","r","c","j","MAP","treeGrid","pRow","pCol","TREE","offset","neg","click","extra","main"],"mappings":"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","sourcesContent":["import React from 'react'\n\nfunction Tile(props) {\n    const {col,row,sType,sId,st,setSt,ch,setCh,gr,setGr,isP,op,setOp,type,count,setCount,txt} = props\n\n\n    const stackGrid = ( size) => {\n        if((row -size) >= -1){\n\n        const newGrid = gr.slice();\n        let tile,newTile,arow,coor =[]\n        for(let i =0;i<size;i++){\n            arow =row-i\n            tile = newGrid[arow][col];\n            newTile= {\n              ...tile,\n              isPicked: !isP,\n              strType: type.STACK,\n              strId:count\n            };\n\n            newGrid[arow][col] = newTile\n            coor.push([arow,col])\n        }\n        setGr(newGrid)\n        let newCount = count +1;\n        setCount(newCount)\n\n        const newSt = st.slice() //copy list of data structues\n        newSt.push({id: count, tile: coor})\n        setSt(newSt)\n        }\n      }\n      \n    const arrayGrid = (size) =>{\n        //setOp(\"\")\n        if((col +size) <= 45){\n\n            const newGrid = gr.slice()\n            let tile, newTile,acol,coor =[]\n            \n\n            for(let i =0;i<size;i++){\n                tile = newGrid[row][col+i]\n                newTile= {\n                ...tile,\n                isPicked: !isP,\n                strType: type.ARRAY,\n                strId:count\n                };\n\n                newGrid[row][col+i] = newTile\n                acol =col+i\n                coor.push([row,acol])\n            }\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n\n            const newSt = st.slice() //copy list of data structues\n            newSt.push({id: count, tile: coor})\n            setSt(newSt)\n            console.log(st)\n        }\n\n    }\n\n    const queueGrid = (size) => {\n        if((col -size) >= -1){\n\n            const newGrid = gr.slice();\n            let tile, newTile,acol,coor =[]\n            for(let i =0;i<size;i++){\n                acol = col-i\n                tile = newGrid[row][acol];\n                newTile= {\n                ...tile,\n                isPicked: !isP,\n                strType: type.QUEUE,\n                strId:count\n\n                };\n\n                newGrid[row][acol] = newTile;\n                coor.push([row,acol])\n            }\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n\n            const newSt = st.slice() //copy list of data structues\n            newSt.push({id: count, tile: coor})\n            setSt(newSt)\n        }\n    }\n    const mapGrid = (size) => {\n        if((col +2) <= 44  && (row +size) <= 20){\n            const newGrid = gr.slice();\n            let tile, newTile,coor =[],arr,r,c\n            for(let i = 0; i<size;i++){\n                arr =[]\n                for(let j = 0;j<3; j++){\n                    r=row+i\n                    c=col+j\n                    tile = newGrid[r][c]\n                    newTile= {\n                    ...tile,\n                    isPicked: !isP,\n                    strType: type.MAP, \n                    strId:count\n\n                    }\n                newGrid[r][c] = newTile; //update tile in copy grid\n                \n                arr.push([r,c]) //pushes for single key/value\n\n                \n                }\n                coor.push(arr)\n            }\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n\n            const newSt = st.slice() //copy list of data structues\n            newSt.push({id: count, tile: coor})\n            setSt(newSt)\n\n        }\n    }\n\n    const treeGrid = () =>{\n        //setOp(\"\")\n        \n\n            const newGrid = gr.slice()\n            let tile, newTile,pRow,pCol,coor =[[row,col]]\n\n            // create  root tile\n            tile = newGrid[row][col]\n            newTile= {\n            ...tile,\n            isPicked: !isP,\n            strType: type.TREE,\n            strId:count\n            };\n\n            newGrid[row][col] = newTile\n            coor.push([row,col])\n            \n            //create children tiles\n            let offset = [4,4,2,2,2,2,1,1,1,1,1,1,1,1],neg =-1\n\n            \n            for(let i =0;i<7;i++){\n                console.log(coor);\n                [pRow,pCol] = coor[i]\n                for(let j = 1; j<3 ;j++){\n                    pRow +=1\n                    pCol = pCol +offset[i]*neg\n                    tile = newGrid[pRow ][pCol ]\n                    newTile= {\n                        ...tile,\n                        isPicked: !isP,\n                        strType: type.TREE,\n                        strId:count\n                    };\n                    neg *= -1\n                    newGrid[pRow+1][pCol +offset[i]*neg] = newTile\n                    coor.push([pRow+1,pCol+offset[i]*neg])\n                }\n                \n\n                \n            }\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n\n            const newSt = st.slice() //copy list of data structues\n            newSt.push({id: count, tile: coor})\n            setSt(newSt)\n            console.log(st)\n        \n\n    }\n\n\n\n    \n    const click =() =>{\n        if(sId ===0){\n            if(op !== \"\"){\n                /*let size= parseInt(prompt(\"Size:\"),10)\n                if(op === \"Array\")\n                    arrayGrid(size)\n                else if(op === \"Stack\")\n                    stackGrid(size)\n                else if(op === \"Queue\")\n                    queueGrid(size)\n                else if(op === \"HashMap\")\n                    mapGrid(size)\n                else */if(op === \"Tree\")\n                    treeGrid()\n                else if(op === \"Graph\")\n                    console.log(\"nothing yet\")\n            }\n        }\n        else{\n            setCh({id:sId , type:sType})\n        }\n    }\n    \n    const extra = sId === ch.id ? 'highlight' : ''\n    const main = sType === ``? ``:\n                sType ===type.ARRAY ? `array` :\n                sType ===type.STACK ? `stack` :\n                sType ===type.QUEUE ? `queue` :\n                sType ===type.MAP ? `map` :\n                sType ===type.TREE ? `tree` :`graph` \n    return (\n        <div className = {` myTile ${main} ${extra}`} \n            onClick = {() => click()} >\n                {txt}\n        </div>\n    )\n}\n\nexport default Tile\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}