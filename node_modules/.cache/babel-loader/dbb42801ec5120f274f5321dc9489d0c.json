{"ast":null,"code":"var _jsxFileName = \"/Users/juvenal/Desktop/projects/StructureVisualizer/structure-vis/src/DataStructureVisualizer/Tile.js\";\nimport React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Tile(props) {\n  const {\n    col,\n    row,\n    sType,\n    sId,\n    st,\n    setSt,\n    ch,\n    setCh,\n    gr,\n    setGr,\n    isP,\n    op,\n    setOp,\n    type,\n    count,\n    setCount,\n    txt,\n    aKey\n  } = props;\n\n  const stackGrid = size => {\n    if (row - size >= -1) {\n      const newGrid = gr.slice();\n      let tile,\n          newTile,\n          arow,\n          coor = [];\n\n      for (let i = 0; i < size; i++) {\n        arow = row - i;\n        tile = newGrid[arow][col];\n        if (tile.strId !== 0) return;\n        newTile = { ...tile,\n          isPicked: !isP,\n          strType: type.STACK,\n          strId: count\n        };\n        newGrid[arow][col] = newTile;\n        coor.push([arow, col]);\n      }\n\n      setGr(newGrid);\n      let newCount = count + 1;\n      setCount(newCount);\n      const newSt = st.slice(); //copy list of data structues\n\n      let top = 0;\n      newSt.push({\n        id: count,\n        type: \"stack\",\n        tile: coor,\n        top: top\n      });\n      setSt(newSt);\n      setOp(\"\");\n    }\n  };\n\n  const arrayGrid = size => {\n    //setOp(\"\")\n    if (col + size <= 39) {\n      const newGrid = gr.slice();\n      let tile,\n          newTile,\n          acol,\n          coor = [];\n\n      for (let i = 0; i < size; i++) {\n        tile = newGrid[row][col + i];\n        if (tile.strId !== 0) return;\n        newTile = { ...tile,\n          isPicked: !isP,\n          strType: type.ARRAY,\n          strId: count\n        };\n        newGrid[row][col + i] = newTile;\n        acol = col + i;\n        coor.push([row, acol]);\n      }\n\n      setGr(newGrid);\n      let newCount = count + 1;\n      setCount(newCount);\n      const newSt = st.slice(); //copy list of data structues\n\n      newSt.push({\n        id: count,\n        type: \"array\",\n        tile: coor\n      });\n      setSt(newSt);\n      console.log(st);\n      setOp(\"\");\n    }\n  };\n\n  const queueGrid = size => {\n    if (col - size >= -1) {\n      const newGrid = gr.slice();\n      let tile,\n          newTile,\n          acol,\n          coor = [];\n\n      for (let i = 0; i < size; i++) {\n        acol = col - i;\n        tile = newGrid[row][acol];\n        if (tile.strId !== 0) return;\n        newTile = { ...tile,\n          isPicked: !isP,\n          strType: type.QUEUE,\n          strId: count\n        };\n        newGrid[row][acol] = newTile;\n        coor.push([row, acol]);\n      }\n\n      setGr(newGrid);\n      let newCount = count + 1;\n      setCount(newCount);\n      const newSt = st.slice(); //copy list of data structues\n\n      newSt.push({\n        id: count,\n        type: \"queue\",\n        tile: coor\n      });\n      setSt(newSt);\n      setOp(\"\");\n    }\n  };\n\n  const mapGrid = size => {\n    if (col + 2 <= 39 && row + size <= 17) {\n      const newGrid = gr.slice();\n      let tile,\n          newTile,\n          coor = [],\n          arr,\n          r,\n          c;\n\n      for (let i = 0; i < size; i++) {\n        arr = [];\n\n        for (let j = 0; j < 3; j++) {\n          r = row + i;\n          c = col + j;\n          tile = newGrid[r][c];\n          if (tile.strId !== 0) return;\n          newTile = { ...tile,\n            isPicked: !isP,\n            strType: type.MAP,\n            strId: count\n          };\n          newGrid[r][c] = newTile; //update tile in copy grid\n\n          arr.push([r, c]); //pushes for single key/value\n        }\n\n        coor.push(arr);\n      }\n\n      setGr(newGrid);\n      let newCount = count + 1;\n      setCount(newCount);\n      const newSt = st.slice(); //copy list of data structues\n\n      newSt.push({\n        id: count,\n        type: \"map\",\n        tile: coor\n      });\n      setSt(newSt);\n      setOp(\"\");\n    }\n  };\n\n  const treeGrid = root => {\n    //setOp(\"\")\n    console.log(root);\n    const newGrid = gr.slice();\n    let tile,\n        newTile,\n        coor = []; // create  root tile\n\n    tile = newGrid[row][col];\n    newTile = { ...tile,\n      isPicked: !isP,\n      txt: `${root}`,\n      strType: type.TREE,\n      strId: count,\n      myKey: aKey\n    };\n    newGrid[row][col] = newTile;\n    coor.push([row, col]);\n    setGr(newGrid);\n    let newCount = count + 1;\n    setCount(newCount);\n    const newSt = st.slice(); //copy list of data structues\n\n    newSt.push({\n      id: count,\n      type: \"tree\",\n      tile: coor\n    });\n    setSt(newSt);\n    setOp(\"\");\n  };\n\n  const graphGrid = () => {\n    //setOp(\"\")\n    const newGrid = gr.slice();\n    let tile,\n        newTile,\n        coor = []; // create  vertex tile\n\n    tile = newGrid[row][col];\n    newTile = { ...tile,\n      isPicked: !isP,\n      txt: `0`,\n      strType: type.GRAPH,\n      strId: count,\n      myKey: aKey\n    };\n    newGrid[row][col] = newTile;\n    coor.push([row, col]);\n    setGr(newGrid);\n    let newCount = count + 1;\n    setCount(newCount);\n    const newSt = st.slice(); //copy list of data structues\n\n    let edg = [];\n    edg.push([]);\n    newSt.push({\n      id: count,\n      type: \"graph\",\n      tile: coor,\n      edges: edg\n    }); //edges = [[],[],[]]\n\n    setSt(newSt);\n    setOp(\"\");\n  };\n\n  const vertexGrid = () => {\n    //setOp(\"\")\n    const newGrid = gr.slice();\n    let tile, newTile;\n    const coor = st.find(e => e.id === ch.id); //find correct graph from all structures\n\n    let myStruc = coor.tile; //array of coordinates of graph [[,],[,],[,]]\n    // create  root tile\n\n    tile = newGrid[row][col];\n    newTile = { ...tile,\n      txt: `${myStruc.length}`,\n      strType: type.GRAPH,\n      strId: ch.id,\n      myKey: aKey\n    };\n    newGrid[row][col] = newTile;\n    myStruc.push([row, col]);\n    let edges = coor.edges;\n    edges.push([]);\n    setGr(newGrid);\n    const newSt = st.filter(e => e.id !== ch.id).slice(); //copy list of data structures without my graph\n\n    const myNewSt = { ...coor,\n      tile: myStruc,\n      edges: edges\n    };\n    newSt.push(myNewSt);\n    setSt(newSt); //setOp(\"\")\n  };\n\n  const click = () => {\n    if (sId === 0) {\n      if (op !== \"\") {\n        if (op === \"Vertex\") vertexGrid();else if (op === \"Graph\") graphGrid();else {\n          let size = parseInt(prompt(\"Size/root:\"), 10);\n          if (op === \"Array\") arrayGrid(size);else if (op === \"Stack\") stackGrid(size);else if (op === \"Queue\") queueGrid(size);else if (op === \"HashMap\") mapGrid(size);else if (op === \"Tree\") treeGrid(size);\n        }\n      }\n    } else {\n      setCh({\n        id: sId,\n        type: sType\n      }); //setOp(sType)\n\n      console.log(ch);\n    }\n  };\n\n  const extra = sId === ch.id ? ' highlight' : '';\n  const main = sType === `` ? `` : sType === type.ARRAY ? `array helper` : sType === type.STACK ? `stack helper` : sType === type.QUEUE ? `queue helper` : sType === type.MAP ? `map helper` : sType === type.TREE ? `tree helper` : `graph helper`;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: `${aKey}`,\n    className: ` myTile ${main} ${extra} `,\n    onClick: () => click(),\n    children: txt\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 290,\n    columnNumber: 9\n  }, this);\n}\n\n_c = Tile;\nexport default Tile;\n\nvar _c;\n\n$RefreshReg$(_c, \"Tile\");","map":{"version":3,"sources":["/Users/juvenal/Desktop/projects/StructureVisualizer/structure-vis/src/DataStructureVisualizer/Tile.js"],"names":["React","Tile","props","col","row","sType","sId","st","setSt","ch","setCh","gr","setGr","isP","op","setOp","type","count","setCount","txt","aKey","stackGrid","size","newGrid","slice","tile","newTile","arow","coor","i","strId","isPicked","strType","STACK","push","newCount","newSt","top","id","arrayGrid","acol","ARRAY","console","log","queueGrid","QUEUE","mapGrid","arr","r","c","j","MAP","treeGrid","root","TREE","myKey","graphGrid","GRAPH","edg","edges","vertexGrid","find","e","myStruc","length","filter","myNewSt","click","parseInt","prompt","extra","main"],"mappings":"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","sourcesContent":["import React from 'react'\n\nfunction Tile(props) {\n    const {col,row,sType,sId,st,setSt,ch,setCh,gr,setGr,isP,op,setOp,type,count,setCount,txt,aKey} = props\n\n\n    const stackGrid = ( size) => {\n        if((row -size) >= -1){\n\n        const newGrid = gr.slice();\n        let tile,newTile,arow,coor =[]\n        for(let i =0;i<size;i++){\n            arow =row-i\n            tile = newGrid[arow][col];\n            if(tile.strId !== 0) \n                return\n            newTile= {\n              ...tile,\n              isPicked: !isP,\n              strType: type.STACK,\n              strId:count\n            };\n\n            newGrid[arow][col] = newTile\n            coor.push([arow,col])\n        }\n        setGr(newGrid)\n        let newCount = count +1;\n        setCount(newCount)\n\n        const newSt = st.slice() //copy list of data structues\n        let top =0\n        newSt.push({id: count,type:\"stack\", tile: coor,top: top})\n        setSt(newSt)\n        setOp(\"\")\n\n        }\n      }\n      \n    const arrayGrid = (size) =>{\n        //setOp(\"\")\n        if((col +size) <= 39){\n\n            const newGrid = gr.slice()\n            let tile, newTile,acol,coor =[]\n            \n\n            for(let i =0;i<size;i++){\n                tile = newGrid[row][col+i]\n                if(tile.strId !== 0) \n                    return\n                newTile= {\n                ...tile,\n                isPicked: !isP,\n                strType: type.ARRAY,\n                strId:count\n                };\n\n                newGrid[row][col+i] = newTile\n                acol =col+i\n                coor.push([row,acol])\n            }\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n\n            const newSt = st.slice() //copy list of data structues\n            newSt.push({id: count,type:\"array\", tile: coor})\n            setSt(newSt)\n            console.log(st)\n            setOp(\"\")\n\n        }\n\n    }\n\n    const queueGrid = (size) => {\n        if((col -size) >= -1){\n\n            const newGrid = gr.slice();\n            let tile, newTile,acol,coor =[]\n            for(let i =0;i<size;i++){\n                acol = col-i\n                tile = newGrid[row][acol];\n                if(tile.strId !== 0) \n                    return\n                newTile= {\n                ...tile,\n                isPicked: !isP,\n                strType: type.QUEUE,\n                strId:count\n\n                };\n\n                newGrid[row][acol] = newTile;\n                coor.push([row,acol])\n            }\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n\n            const newSt = st.slice() //copy list of data structues\n            newSt.push({id: count,type:\"queue\", tile: coor})\n            setSt(newSt)\n            setOp(\"\")\n\n        }\n    }\n    const mapGrid = (size) => {\n        if((col +2) <= 39  && (row +size) <= 17){\n            const newGrid = gr.slice();\n            let tile, newTile,coor =[],arr,r,c\n            for(let i = 0; i<size;i++){\n                arr =[]\n                for(let j = 0;j<3; j++){\n                    r=row+i\n                    c=col+j\n                    tile = newGrid[r][c]\n                    if(tile.strId !== 0) \n                        return\n                    newTile= {\n                    ...tile,\n                    isPicked: !isP,\n                    strType: type.MAP, \n                    strId:count\n\n                    }\n                newGrid[r][c] = newTile; //update tile in copy grid\n                \n                arr.push([r,c]) //pushes for single key/value\n\n                \n                }\n                coor.push(arr)\n            }\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n\n            const newSt = st.slice() //copy list of data structues\n            newSt.push({id: count,type:\"map\", tile: coor})\n            setSt(newSt)\n            setOp(\"\")\n\n        }\n    }\n\n    const treeGrid = (root) =>{\n        //setOp(\"\")\n        \n            console.log(root)\n            const newGrid = gr.slice()\n            let tile, newTile,coor =[]\n\n            // create  root tile\n            tile = newGrid[row][col]\n            newTile= {\n            ...tile,\n            isPicked: !isP,\n            txt:`${root}`,\n            strType: type.TREE,\n            strId:count,\n            myKey: aKey\n            };\n\n            newGrid[row][col] = newTile\n            coor.push([row,col])\n\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n            const newSt = st.slice() //copy list of data structues\n            newSt.push({id: count, type:\"tree\",tile: coor})\n            setSt(newSt)\n            setOp(\"\")\n            \n    }\n\n    const graphGrid = () =>{\n        //setOp(\"\")\n        \n            const newGrid = gr.slice()\n            let tile, newTile,coor =[]\n\n            // create  vertex tile\n            tile = newGrid[row][col]\n            newTile= {\n            ...tile,\n            isPicked: !isP,\n            txt:`0`,\n            strType: type.GRAPH,\n            strId:count,\n            myKey: aKey\n            };\n\n            newGrid[row][col] = newTile\n            coor.push([row,col])\n\n            setGr(newGrid)\n            let newCount = count +1;\n            setCount(newCount)\n            const newSt = st.slice() //copy list of data structues\n            let edg = []\n            edg.push([])\n            newSt.push({id: count, type:\"graph\",tile: coor, edges:edg})//edges = [[],[],[]]\n            setSt(newSt)\n            setOp(\"\")\n\n            \n    }\n\n    const vertexGrid = () =>{\n        //setOp(\"\")\n        \n            const newGrid = gr.slice()\n            let tile, newTile\n            const coor = (st.find(e => e.id === ch.id)) //find correct graph from all structures\n            let myStruc = coor.tile //array of coordinates of graph [[,],[,],[,]]\n\n            // create  root tile\n            tile = newGrid[row][col]\n            newTile= {\n            ...tile,\n            txt:`${myStruc.length}`,\n            strType: type.GRAPH,\n            strId:ch.id,\n            myKey: aKey\n            };\n\n            newGrid[row][col] = newTile\n            myStruc.push([row,col])\n\n            let edges = coor.edges\n            edges.push([])\n\n            setGr(newGrid)\n            const newSt = st.filter((e => e.id !== ch.id)).slice() //copy list of data structures without my graph\n            const myNewSt = {...coor,tile:myStruc,edges:edges}\n            newSt.push(myNewSt)\n            setSt(newSt)\n            //setOp(\"\")\n\n            \n    }\n\n\n\n\n    \n    const click =() =>{\n        if(sId ===0){\n            if(op !== \"\"){\n                if(op===\"Vertex\")\n                    vertexGrid()\n                else if(op === \"Graph\")\n                    graphGrid()\n                else{\n                    let size= parseInt(prompt(\"Size/root:\"),10)\n\n                    if(op === \"Array\")\n                        arrayGrid(size)\n                    else if(op === \"Stack\")\n                        stackGrid(size)\n                    else if(op === \"Queue\")\n                        queueGrid(size)\n                    else if(op === \"HashMap\")\n                        mapGrid(size)\n                    else if(op === \"Tree\")\n                        treeGrid(size)\n                    \n            }\n            }\n        }\n        else{\n            setCh({id:sId , type:sType})\n            //setOp(sType)\n            console.log(ch)\n\n        }\n    }\n\n    const extra = sId === ch.id ? ' highlight' : ''\n    const main = sType === ``? ``:\n                sType ===type.ARRAY ? `array helper` :\n                sType ===type.STACK ? `stack helper` :\n                sType ===type.QUEUE ? `queue helper` :\n                sType ===type.MAP ? `map helper` :\n                sType ===type.TREE ? `tree helper` :`graph helper` \n    return (\n        <div id={`${aKey}`} className = {` myTile ${main} ${extra} `} \n            onClick = {() => click()} >\n                {txt}\n        </div>\n    )\n}\n\nexport default Tile\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}